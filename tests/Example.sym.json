[{"isProp":false,"kind":"definition","name":["Demo","_aux_Example___unexpand_BEq_beq_1"],"typeFallback":"Lean.PrettyPrinter.Unexpander","typeFull":"Lean.PrettyPrinter.Unexpander","typeReadable":null,"typeReferences":[["Lean","PrettyPrinter","Unexpander"]],"valueReferences":[["Lean","Name"],["Lean","TSyntax","raw"],["Bool","false"],["Lean","MonadQuotation","getCurrMacroScope"],["Lean","MacroScope"],["Lean","SourceInfo"],["Lean","MonadQuotation","toMonadRef"],["Lean","MonadRef","mkInfoFromRefPos"],["ReaderT","instApplicativeOfMonad"],["List","cons"],["Bool","true"],["Unit","unit"],["MonadExcept","throw"],["Lean","Name","mkStr4"],["Lean","SyntaxNodeKind"],["Lean","TSyntax","mk"],["EStateM","instMonad"],["Lean","PrettyPrinter","instMonadQuotationUnexpandM"],["instMonadExceptOfMonadExceptOf"],["Lean","Syntax"],["Bool","or"],["cond"],["Unit"],["instDecidableEqBool"],["Nat"],["Monad","toBind"],["Lean","Syntax","atom"],["Lean","withRef"],["Bool"],["Applicative","toPure"],["Lean","PrettyPrinter","UnexpandM"],["ReaderT","instMonadExceptOf"],["EStateM"],["Lean","Syntax","isOfKind"],["Lean","Syntax","matchesNull"],["PUnit"],["instOfNatNat"],["Lean","MonadQuotation","getContext"],["Eq"],["Lean","Name","mkStr2"],["List","nil"],["Bind","bind"],["EStateM","instMonadExceptOfOfBacktrackable"],["Lean","Name","mkStr1"],["ite"],["Lean","Syntax","node3"],["ReaderT","instMonad"],["OfNat","ofNat"],["EStateM","nonBacktrackable"],["Lean","Syntax","getArg"],["Pure","pure"]]},{"isProp":true,"kind":"theorem","name":["FermatTriple","eqn"],"typeFallback":"forall {k : Nat} (self : FermatTriple k), Eq.{1} Nat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) (FermatTriple.x k self) k) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) (FermatTriple.y k self) k)) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) (FermatTriple.z k self) k)","typeFull":"∀ {k : Nat} (self : FermatTriple k),\n  Eq (instHAdd.hAdd (instHPow.hPow self.x k) (instHPow.hPow self.y k)) (instHPow.hPow self.z k)","typeReadable":null,"typeReferences":[["instAddNat"],["instHPow"],["instHAdd"],["instPowNat"],["HPow","hPow"],["instNatPowNat"],["FermatTriple"],["HAdd","hAdd"],["Nat"],["FermatTriple","z"],["FermatTriple","x"],["Eq"],["FermatTriple","y"]],"valueReferences":[]},{"isProp":false,"kind":"definition","name":["FermatTriple","y"],"typeFallback":"forall {k : Nat}, (FermatTriple k) -> Nat","typeFull":"{k : Nat} → FermatTriple k → Nat","typeReadable":null,"typeReferences":[["Nat"],["FermatTriple"]],"valueReferences":[]},{"isProp":true,"kind":"theorem","name":["coe_test"],"typeFallback":"forall (n : Nat), (Eq.{1} Nat n (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) -> (Eq.{1} Int (Nat.cast.{0} Int instNatCastInt n) (OfNat.ofNat.{0} Int 0 (instOfNat 0)))","typeFull":"∀ (n : Nat), Eq n 0 → Eq n.cast 0","typeReadable":null,"typeReferences":[["Nat"],["Nat","cast"],["instOfNat"],["instOfNatNat"],["Eq"],["OfNat","ofNat"],["instNatCastInt"],["Int"]],"valueReferences":[["Nat","cast"],["Eq","trans"],["True"],["OfNat","ofNat"],["Int"],["congrArg"],["eq_self"],["Nat"],["of_eq_true"],["instOfNat"],["instOfNatNat"],["Eq"],["instNatCastInt"]]},{"isProp":true,"kind":"theorem","name":["FermatTriple","mk","inj"],"typeFallback":"forall {k : Nat} {x : Nat} {y : Nat} {z : Nat} {eqn : Eq.{1} Nat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) x k) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) y k)) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) z k)} {x_1 : Nat} {y_1 : Nat} {z_1 : Nat} {eqn_1 : Eq.{1} Nat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) x_1 k) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) y_1 k)) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) z_1 k)}, (Eq.{1} (FermatTriple k) (FermatTriple.mk k x y z eqn) (FermatTriple.mk k x_1 y_1 z_1 eqn_1)) -> (And (Eq.{1} Nat x x_1) (And (Eq.{1} Nat y y_1) (Eq.{1} Nat z z_1)))","typeFull":"∀ {k x y z : Nat} {eqn : Eq (instHAdd.hAdd (instHPow.hPow x k) (instHPow.hPow y k)) (instHPow.hPow z k)}\n  {x_1 y_1 z_1 : Nat} {eqn_1 : Eq (instHAdd.hAdd (instHPow.hPow x_1 k) (instHPow.hPow y_1 k)) (instHPow.hPow z_1 k)},\n  Eq { x := x, y := y, z := z, eqn := eqn } { x := x_1, y := y_1, z := z_1, eqn := eqn_1 } →\n    And (Eq x x_1) (And (Eq y y_1) (Eq z z_1))","typeReadable":null,"typeReferences":[["FermatTriple","mk"],["instHPow"],["instAddNat"],["HAdd","hAdd"],["Nat"],["instHAdd"],["And"],["instPowNat"],["instNatPowNat"],["HPow","hPow"],["Eq"],["FermatTriple"]],"valueReferences":[["And","intro"],["Nat"],["And"],["Eq"],["FermatTriple","mk","noConfusion"]]},{"isProp":false,"kind":"inductive","name":["Demo","MyType"],"typeFallback":"Type","typeFull":"Type","typeReadable":null,"typeReferences":[],"valueReferences":null},{"isProp":true,"kind":"theorem","name":["Demo","MyType","val","sizeOf_spec"],"typeFallback":"Eq.{1} Nat (SizeOf.sizeOf.{1} Demo.MyType Demo.MyType._sizeOf_inst Demo.MyType.val) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))","typeFull":"Eq (Demo.MyType._sizeOf_inst.sizeOf Demo.MyType.val) 1","typeReadable":null,"typeReferences":[["Demo","MyType"],["SizeOf","sizeOf"],["Nat"],["instOfNatNat"],["Demo","MyType","val"],["Demo","MyType","_sizeOf_inst"],["Eq"],["OfNat","ofNat"]],"valueReferences":[["Nat"],["instOfNatNat"],["Eq","refl"],["OfNat","ofNat"]]},{"isProp":true,"kind":"theorem","name":["simp_test"],"typeFallback":"forall (x : Nat) (y : Nat) (z : Nat) (p : Nat -> Prop), (p (HMul.hMul.{0, 0, 0} Nat Nat Nat (instHMul.{0} Nat instMulNat) x y)) -> (p (HMul.hMul.{0, 0, 0} Nat Nat Nat (instHMul.{0} Nat instMulNat) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) x (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) (HMul.hMul.{0, 0, 0} Nat Nat Nat (instHMul.{0} Nat instMulNat) y (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (HMul.hMul.{0, 0, 0} Nat Nat Nat (instHMul.{0} Nat instMulNat) z (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))","typeFull":"∀ (x y z : Nat) (p : Nat → Prop),\n  p (instHMul.hMul x y) →\n    p (instHMul.hMul (instHAdd.hAdd x 0) (instHAdd.hAdd (instHAdd.hAdd 0 (instHMul.hMul y 1)) (instHMul.hMul z 0)))","typeReadable":null,"typeReferences":[["instAddNat"],["HAdd","hAdd"],["Nat"],["instOfNatNat"],["instHAdd"],["instMulNat"],["instHMul"],["HMul","hMul"],["OfNat","ofNat"]],"valueReferences":[["Nat","mul_one"],["instAddNat"],["Eq","trans"],["instHAdd"],["Nat","zero_add"],["HMul","hMul"],["OfNat","ofNat"],["congrArg"],["HAdd","hAdd"],["Nat"],["instOfNatNat"],["instMulNat"],["id"],["instHMul"],["Eq","mpr"],["Eq"]]},{"isProp":true,"kind":"definition","name":["Sum","IsRight","recOn"],"typeFallback":"forall {α : Type.{u}} {β : Type.{u_1}} {motive : forall (a._@._internal._hyg.0 : Sum.{u, u_1} α β), (Sum.IsRight.{u, u_1} α β a._@._internal._hyg.0) -> Prop} {a._@._internal._hyg.0 : Sum.{u, u_1} α β} (t : Sum.IsRight.{u, u_1} α β a._@._internal._hyg.0), (forall {b : β}, motive (Sum.inr.{u, u_1} α β b) (Sum.IsRight.of_right.{u, u_1} α β b)) -> (motive a._@._internal._hyg.0 t)","typeFull":"∀ {α : Type u} {β : Type u_1} {motive : (a : Sum α β) → a.IsRight → Prop} {a : Sum α β} (t : a.IsRight),\n  (∀ {b : β}, motive (Sum.inr b) ⋯) → motive a t","typeReadable":null,"typeReferences":[["Sum","IsRight"],["Sum","IsRight","of_right"],["Sum","inr"],["Sum"]],"valueReferences":[["Sum","IsRight","rec"]]},{"isProp":false,"kind":"definition","name":["Option","instDecidablePredIsSome","match_1"],"typeFallback":"forall {α : Type.{u_1}} (motive : (Option.{u_1} α) -> Sort.{u_2}) (a._@.Example.2435856334._hygCtx._hyg.14 : Option.{u_1} α), (forall (val._@.Example.2435856334._hygCtx._hyg.21 : α), motive (Option.some.{u_1} α val._@.Example.2435856334._hygCtx._hyg.21)) -> (Unit -> (motive (Option.none.{u_1} α))) -> (motive a._@.Example.2435856334._hygCtx._hyg.14)","typeFull":"{α : Type u_1} →\n  (motive : Option α → Sort u_2) →\n    (a : Option α) → ((val : α) → motive (Option.some val)) → (Unit → motive Option.none) → motive a","typeReadable":null,"typeReferences":[["Option","none"],["Option"],["Option","some"],["Unit"]],"valueReferences":[["Option","casesOn"],["Unit","unit"]]},{"isProp":false,"kind":"definition","name":["FermatTriple","ctorIdx"],"typeFallback":"forall {k : Nat}, (FermatTriple k) -> Nat","typeFull":"{k : Nat} → FermatTriple k → Nat","typeReadable":null,"typeReferences":[["Nat"],["FermatTriple"]],"valueReferences":[]},{"isProp":true,"kind":"theorem","name":["_private","Example",0,"List","getLast?","match_1","eq_2"],"typeFallback":"forall {α : Type.{u_1}} (motive : (List.{u_1} α) -> Sort.{u_2}) (a : α) (as : List.{u_1} α) (h_1 : Unit -> (motive (List.nil.{u_1} α))) (h_2 : forall (a : α) (as : List.{u_1} α), motive (List.cons.{u_1} α a as)), Eq.{u_2} (motive (List.cons.{u_1} α a as)) (List.getLast?.match_1.{u_1, u_2} α motive (List.cons.{u_1} α a as) h_1 h_2) (h_2 a as)","typeFull":"∀ {α : Type u_1} (motive : List α → Sort u_2) (a : α) (as : List α) (h_1 : Unit → motive List.nil)\n  (h_2 : (a : α) → (as : List α) → motive (List.cons a as)),\n  Eq (List.getLast?.match_1 motive (List.cons a as) h_1 h_2) (h_2 a as)","typeReadable":null,"typeReferences":[["List","nil"],["List"],["List","getLast?","match_1"],["Eq"],["List","cons"],["Unit"]],"valueReferences":[["Eq","refl"],["List","getLast?","match_1"],["List","cons"]]},{"isProp":false,"kind":"definition","name":["_private","Example",0,"List","length","match_1","splitter"],"typeFallback":"forall {α : Type.{u_1}} (motive : (List.{u_1} α) -> Sort.{u_2}) (x._@.Init.Prelude.210037673._hygCtx.9.Init.Prelude.210037673._hygCtx._hyg.20 : List.{u_1} α), (motive (List.nil.{u_1} α)) -> (forall (head._@.Init.Prelude.210037673._hygCtx._hyg.34 : α) (as : List.{u_1} α), motive (List.cons.{u_1} α head._@.Init.Prelude.210037673._hygCtx._hyg.34 as)) -> (motive x._@.Init.Prelude.210037673._hygCtx.9.Init.Prelude.210037673._hygCtx._hyg.20)","typeFull":"{α : Type u_1} →\n  (motive : List α → Sort u_2) →\n    (x : List α) → motive List.nil → ((head : α) → (as : List α) → motive (List.cons head as)) → motive x","typeReadable":null,"typeReferences":[["List","nil"],["List"],["List","cons"]],"valueReferences":[["List","casesOn"]]},{"isProp":false,"kind":"constructor","name":["Demo","MyType","val"],"typeFallback":"Demo.MyType","typeFull":"Demo.MyType","typeReadable":null,"typeReferences":[["Demo","MyType"]],"valueReferences":null},{"isProp":false,"kind":"definition","name":["open_scoped_test1"],"typeFallback":"IO Unit","typeFull":"IO Unit","typeReadable":null,"typeReferences":[["IO"],["Unit"]],"valueReferences":[["Demo","MyType"],["Bool"],["instToStringString"],["ite"],["Unit"],["instDecidableEqBool"],["String"],["Demo","MyType","val"],["IO"],["IO","println"],["Eq"],["BEq","beq"],["Bool","true"],["Demo","instBEqMyType"]]},{"isProp":false,"kind":"definition","name":["hello"],"typeFallback":"IO Unit","typeFull":"IO Unit","typeReadable":null,"typeReferences":[["IO"],["Unit"]],"valueReferences":[["String"],["instToStringString"],["IO","println"]]},{"isProp":false,"kind":"inductive","name":["Sum","IsRight"],"typeFallback":"forall {α : Type.{u}} {β : Type.{u_1}}, (Sum.{u, u_1} α β) -> Prop","typeFull":"{α : Type u} → {β : Type u_1} → Sum α β → Prop","typeReadable":null,"typeReferences":[["Sum"]],"valueReferences":null},{"isProp":false,"kind":"definition","name":["Demo","MyType","casesOn"],"typeFallback":"forall {motive : Demo.MyType -> Sort.{u}} (t : Demo.MyType), (motive Demo.MyType.val) -> (motive t)","typeFull":"{motive : Demo.MyType → Sort u} → (t : Demo.MyType) → motive Demo.MyType.val → motive t","typeReadable":null,"typeReferences":[["Demo","MyType"],["Demo","MyType","val"]],"valueReferences":[["Demo","MyType","rec"]]},{"isProp":false,"kind":"definition","name":["FermatTriple","mk","_flat_ctor"],"typeFallback":"forall {k : Nat} (x : Nat) (y : Nat) (z : Nat), (Eq.{1} Nat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) x k) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) y k)) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) z k)) -> (FermatTriple k)","typeFull":"{k : Nat} →\n  (x y z : Nat) → Eq (instHAdd.hAdd (instHPow.hPow x k) (instHPow.hPow y k)) (instHPow.hPow z k) → FermatTriple k","typeReadable":null,"typeReferences":[["instHPow"],["instAddNat"],["HAdd","hAdd"],["Nat"],["instHAdd"],["instPowNat"],["instNatPowNat"],["HPow","hPow"],["Eq"],["FermatTriple"]],"valueReferences":[["FermatTriple","mk"]]},{"isProp":true,"kind":"theorem","name":["dsimp_test"],"typeFallback":"forall (x : Nat) (y : Nat) (z : Nat) (p : Nat -> Prop), (p (HMul.hMul.{0, 0, 0} Nat Nat Nat (instHMul.{0} Nat instMulNat) x y)) -> (p (HMul.hMul.{0, 0, 0} Nat Nat Nat (instHMul.{0} Nat instMulNat) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) x (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) (HMul.hMul.{0, 0, 0} Nat Nat Nat (instHMul.{0} Nat instMulNat) y (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (HMul.hMul.{0, 0, 0} Nat Nat Nat (instHMul.{0} Nat instMulNat) z (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))","typeFull":"∀ (x y z : Nat) (p : Nat → Prop),\n  p (instHMul.hMul x y) →\n    p (instHMul.hMul (instHAdd.hAdd x 0) (instHAdd.hAdd (instHAdd.hAdd 0 (instHMul.hMul y 1)) (instHMul.hMul z 0)))","typeReadable":null,"typeReferences":[["instAddNat"],["HAdd","hAdd"],["Nat"],["instOfNatNat"],["instHAdd"],["instMulNat"],["instHMul"],["HMul","hMul"],["OfNat","ofNat"]],"valueReferences":[["Nat","mul_one"],["instAddNat"],["Eq","trans"],["True"],["instHAdd"],["Nat","zero_add"],["eq_true"],["HMul","hMul"],["OfNat","ofNat"],["congrArg"],["HAdd","hAdd"],["Nat"],["of_eq_true"],["instOfNatNat"],["congr"],["instMulNat"],["instHMul"],["Nat","mul_zero"]]},{"isProp":false,"kind":"definition","name":["FermatTriple","recOn"],"typeFallback":"forall {k : Nat} {motive : (FermatTriple k) -> Sort.{u}} (t : FermatTriple k), (forall (x : Nat) (y : Nat) (z : Nat) (eqn : Eq.{1} Nat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) x k) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) y k)) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) z k)), motive (FermatTriple.mk k x y z eqn)) -> (motive t)","typeFull":"{k : Nat} →\n  {motive : FermatTriple k → Sort u} →\n    (t : FermatTriple k) →\n      ((x y z : Nat) →\n          (eqn : Eq (instHAdd.hAdd (instHPow.hPow x k) (instHPow.hPow y k)) (instHPow.hPow z k)) →\n            motive { x := x, y := y, z := z, eqn := eqn }) →\n        motive t","typeReadable":null,"typeReferences":[["FermatTriple","mk"],["instHPow"],["instAddNat"],["HAdd","hAdd"],["Nat"],["instHAdd"],["instPowNat"],["instNatPowNat"],["HPow","hPow"],["Eq"],["FermatTriple"]],"valueReferences":[["FermatTriple","rec"]]},{"isProp":false,"kind":"definition","name":["Demo","instBEqMyType"],"typeFallback":"BEq.{0} Demo.MyType","typeFull":"BEq Demo.MyType","typeReadable":null,"typeReferences":[["Demo","MyType"],["BEq"]],"valueReferences":[["Demo","MyType"],["BEq","mk"],["Bool","true"]]},{"isProp":true,"kind":"definition","name":["Option","IsSome","recOn"],"typeFallback":"forall {α : Type.{u}} {motive : forall (a._@._internal._hyg.0 : Option.{u} α), (Option.IsSome.{u} α a._@._internal._hyg.0) -> Prop} {a._@._internal._hyg.0 : Option.{u} α} (t : Option.IsSome.{u} α a._@._internal._hyg.0), (forall {a : α}, motive (Option.some.{u} α a) (Option.IsSome.of_some.{u} α a)) -> (motive a._@._internal._hyg.0 t)","typeFull":"∀ {α : Type u} {motive : (a : Option α) → a.IsSome → Prop} {a : Option α} (t : a.IsSome),\n  (∀ {a : α}, motive (Option.some a) ⋯) → motive a t","typeReadable":null,"typeReferences":[["Option","IsSome","of_some"],["Option","IsSome"],["Option"],["Option","some"]],"valueReferences":[["Option","IsSome","rec"]]},{"isProp":false,"kind":"definition","name":["pow'","_unsafe_rec"],"typeFallback":"forall {α : Type.{u}} [inst._@.Example.1123838625._hygCtx._hyg.3 : Mul.{u} α], α -> Nat -> α","typeFull":"{α : Type u} → [Mul α] → α → Nat → α","typeReadable":null,"typeReferences":[["Nat"],["Mul"]],"valueReferences":[["pow'","match_1"],["instHMul"],["HMul","hMul"],["pow'","_unsafe_rec"]]},{"isProp":true,"kind":"theorem","name":["_private","Example",0,"List","length","match_1","eq_1"],"typeFallback":"forall {α : Type.{u_1}} (motive : (List.{u_1} α) -> Sort.{u_2}) (h_1 : Unit -> (motive (List.nil.{u_1} α))) (h_2 : forall (head._@.Init.Prelude.210037673._hygCtx._hyg.34 : α) (as : List.{u_1} α), motive (List.cons.{u_1} α head._@.Init.Prelude.210037673._hygCtx._hyg.34 as)), Eq.{u_2} (motive (List.nil.{u_1} α)) (List.length.match_1.{u_1, u_2} α motive (List.nil.{u_1} α) h_1 h_2) (h_1 Unit.unit)","typeFull":"∀ {α : Type u_1} (motive : List α → Sort u_2) (h_1 : Unit → motive List.nil)\n  (h_2 : (head : α) → (as : List α) → motive (List.cons head as)),\n  Eq (List.length.match_1 motive List.nil h_1 h_2) (h_1 Unit.unit)","typeReadable":null,"typeReferences":[["List","nil"],["List"],["List","length","match_1"],["Eq"],["List","cons"],["Unit","unit"],["Unit"]],"valueReferences":[["List","nil"],["Eq","refl"],["List","length","match_1"]]},{"isProp":false,"kind":"definition","name":["Demo","MyType","ctorIdx"],"typeFallback":"Demo.MyType -> Nat","typeFull":"Demo.MyType → Nat","typeReadable":null,"typeReferences":[["Demo","MyType"],["Nat"]],"valueReferences":[]},{"isProp":false,"kind":"definition","name":["Demo","MyType","noConfusion"],"typeFallback":"forall {P : Sort.{v._@.Example.1702421504._hygCtx._hyg.7}} {x : Demo.MyType} {y : Demo.MyType}, (Eq.{1} Demo.MyType x y) -> (Demo.MyType.noConfusionType.{v._@.Example.1702421504._hygCtx._hyg.7} P x y)","typeFull":"{P : Sort v✝} → {x y : Demo.MyType} → Eq x y → Demo.MyType.noConfusionType P x y","typeReadable":null,"typeReferences":[["Demo","MyType"],["Demo","MyType","noConfusionType"],["Eq"]],"valueReferences":[]},{"isProp":false,"kind":"recursor","name":["Demo","MyType","rec"],"typeFallback":"forall {motive : Demo.MyType -> Sort.{u}}, (motive Demo.MyType.val) -> (forall (t : Demo.MyType), motive t)","typeFull":"{motive : Demo.MyType → Sort u} → motive Demo.MyType.val → (t : Demo.MyType) → motive t","typeReadable":null,"typeReferences":[["Demo","MyType"],["Demo","MyType","val"]],"valueReferences":null},{"isProp":false,"kind":"constructor","name":["FermatTriple","mk"],"typeFallback":"forall {k : Nat} (x : Nat) (y : Nat) (z : Nat), (Eq.{1} Nat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) x k) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) y k)) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) z k)) -> (FermatTriple k)","typeFull":"{k : Nat} →\n  (x y z : Nat) → Eq (instHAdd.hAdd (instHPow.hPow x k) (instHPow.hPow y k)) (instHPow.hPow z k) → FermatTriple k","typeReadable":null,"typeReferences":[["instHPow"],["instAddNat"],["HAdd","hAdd"],["Nat"],["instHAdd"],["instPowNat"],["instNatPowNat"],["HPow","hPow"],["Eq"],["FermatTriple"]],"valueReferences":null},{"isProp":true,"kind":"theorem","name":["map_length"],"typeFallback":"forall {α : Type.{u}} (f : α -> α) (l : List.{u} α), Eq.{1} Nat (List.length.{u} α (List.map.{u, u} α α f l)) (List.length.{u} α l)","typeFull":"∀ {α : Type u} (f : α → α) (l : List α), Eq (List.map f l).length l.length","typeReadable":null,"typeReferences":[["Nat"],["List","map"],["List"],["Eq"],["List","length"]],"valueReferences":[["instAddNat"],["List","rec"],["List","nil"],["instHAdd"],["List","map","eq_def"],["List","map"],["List"],["List","length","match_1"],["List","getLast?","match_1"],["OfNat","ofNat"],["congrArg"],["HAdd","hAdd"],["Nat"],["instOfNatNat"],["congr"],["Eq","refl"],["id"],["Eq","mpr"],["Eq"],["List","cons"],["List","length","eq_def"],["List","length"]]},{"isProp":true,"kind":"theorem","name":["List","map","eq_def"],"typeFallback":"forall {α : Type.{u}} {β : Type.{v}} (f : α -> β) (x._@.Init.Data.List.Basic.3880878766._hygCtx._hyg.13 : List.{u} α), Eq.{succ v} (List.{v} β) (List.map.{u, v} α β f x._@.Init.Data.List.Basic.3880878766._hygCtx._hyg.13) (List.getLast?.match_1.{u, succ v} α (fun (x._@.Init.Data.List.Basic.3880878766._hygCtx.13.Init.Data.List.Basic.3880878766._hygCtx._hyg.24 : List.{u} α) => List.{v} β) x._@.Init.Data.List.Basic.3880878766._hygCtx._hyg.13 (fun (_ : Unit) => List.nil.{v} β) (fun (a : α) (as : List.{u} α) => List.cons.{v} β (f a) (List.map.{u, v} α β f as)))","typeFull":"∀ {α : Type u} {β : Type v} (f : α → β) (x : List α),\n  Eq (List.map f x)\n    (List.getLast?.match_1 (fun x => List β) x (fun _ => List.nil) fun a as => List.cons (f a) (List.map f as))","typeReadable":null,"typeReferences":[["List","nil"],["List","map"],["List"],["List","getLast?","match_1"],["Eq"],["List","cons"]],"valueReferences":[["List","nil"],["List","map"],["List","map","eq_1"],["List"],["List","map","eq_2"],["List","getLast?","match_1"],["_private","Example",0,"List","getLast?","match_1","splitter"],["Eq","refl"],["id"],["Eq","symm"],["Eq"],["Eq","ndrec"],["List","cons"]]},{"isProp":false,"kind":"definition","name":["FermatTriple","casesOn"],"typeFallback":"forall {k : Nat} {motive : (FermatTriple k) -> Sort.{u}} (t : FermatTriple k), (forall (x : Nat) (y : Nat) (z : Nat) (eqn : Eq.{1} Nat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) x k) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) y k)) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) z k)), motive (FermatTriple.mk k x y z eqn)) -> (motive t)","typeFull":"{k : Nat} →\n  {motive : FermatTriple k → Sort u} →\n    (t : FermatTriple k) →\n      ((x y z : Nat) →\n          (eqn : Eq (instHAdd.hAdd (instHPow.hPow x k) (instHPow.hPow y k)) (instHPow.hPow z k)) →\n            motive { x := x, y := y, z := z, eqn := eqn }) →\n        motive t","typeReadable":null,"typeReferences":[["FermatTriple","mk"],["instHPow"],["instAddNat"],["HAdd","hAdd"],["Nat"],["instHAdd"],["instPowNat"],["instNatPowNat"],["HPow","hPow"],["Eq"],["FermatTriple"]],"valueReferences":[["FermatTriple","rec"]]},{"isProp":false,"kind":"definition","name":["FermatTriple","x"],"typeFallback":"forall {k : Nat}, (FermatTriple k) -> Nat","typeFull":"{k : Nat} → FermatTriple k → Nat","typeReadable":null,"typeReferences":[["Nat"],["FermatTriple"]],"valueReferences":[]},{"isProp":true,"kind":"theorem","name":["cdot_test"],"typeFallback":"And (forall (A : Prop), A -> A) True","typeFull":"And (∀ (A : Prop), A → A) True","typeReadable":null,"typeReferences":[["True"],["And"]],"valueReferences":[["And","intro"],["True"],["True","intro"]]},{"isProp":false,"kind":"definition","name":["Demo","MyType","recOn"],"typeFallback":"forall {motive : Demo.MyType -> Sort.{u}} (t : Demo.MyType), (motive Demo.MyType.val) -> (motive t)","typeFull":"{motive : Demo.MyType → Sort u} → (t : Demo.MyType) → motive Demo.MyType.val → motive t","typeReadable":null,"typeReferences":[["Demo","MyType"],["Demo","MyType","val"]],"valueReferences":[["Demo","MyType","rec"]]},{"isProp":false,"kind":"inductive","name":["Option","IsSome"],"typeFallback":"forall {α : Type.{u}}, (Option.{u} α) -> Prop","typeFull":"{α : Type u} → Option α → Prop","typeReadable":null,"typeReferences":[["Option"]],"valueReferences":null},{"isProp":true,"kind":"recursor","name":["Option","IsSome","rec"],"typeFallback":"forall {α : Type.{u}} {motive : forall (a._@._internal._hyg.0 : Option.{u} α), (Option.IsSome.{u} α a._@._internal._hyg.0) -> Prop}, (forall {a : α}, motive (Option.some.{u} α a) (Option.IsSome.of_some.{u} α a)) -> (forall {a._@._internal._hyg.0 : Option.{u} α} (t : Option.IsSome.{u} α a._@._internal._hyg.0), motive a._@._internal._hyg.0 t)","typeFull":"∀ {α : Type u} {motive : (a : Option α) → a.IsSome → Prop},\n  (∀ {a : α}, motive (Option.some a) ⋯) → ∀ {a : Option α} (t : a.IsSome), motive a t","typeReadable":null,"typeReferences":[["Option","IsSome","of_some"],["Option","IsSome"],["Option"],["Option","some"]],"valueReferences":null},{"isProp":false,"kind":"definition","name":["open_scoped_test2"],"typeFallback":"Nat -> Nat","typeFull":"Nat → Nat","typeReadable":null,"typeReferences":[["Nat"]],"valueReferences":[["instAddNat"],["HAdd","hAdd"],["Nat"],["instHAdd"]]},{"isProp":false,"kind":"recursor","name":["FermatTriple","rec"],"typeFallback":"forall {k : Nat} {motive : (FermatTriple k) -> Sort.{u}}, (forall (x : Nat) (y : Nat) (z : Nat) (eqn : Eq.{1} Nat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) x k) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) y k)) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) z k)), motive (FermatTriple.mk k x y z eqn)) -> (forall (t : FermatTriple k), motive t)","typeFull":"{k : Nat} →\n  {motive : FermatTriple k → Sort u} →\n    ((x y z : Nat) →\n        (eqn : Eq (instHAdd.hAdd (instHPow.hPow x k) (instHPow.hPow y k)) (instHPow.hPow z k)) →\n          motive { x := x, y := y, z := z, eqn := eqn }) →\n      (t : FermatTriple k) → motive t","typeReadable":null,"typeReferences":[["FermatTriple","mk"],["instHPow"],["instAddNat"],["HAdd","hAdd"],["Nat"],["instHAdd"],["instPowNat"],["instNatPowNat"],["HPow","hPow"],["Eq"],["FermatTriple"]],"valueReferences":null},{"isProp":true,"kind":"constructor","name":["Option","IsSome","of_some"],"typeFallback":"forall {α : Type.{u}} {a : α}, Option.IsSome.{u} α (Option.some.{u} α a)","typeFull":"∀ {α : Type u} {a : α}, (Option.some a).IsSome","typeReadable":null,"typeReferences":[["Option","IsSome"],["Option","some"]],"valueReferences":null},{"isProp":true,"kind":"constructor","name":["Sum","IsRight","of_right"],"typeFallback":"forall {α : Type.{u}} {β : Type.{u_1}} {b : β}, Sum.IsRight.{u, u_1} α β (Sum.inr.{u, u_1} α β b)","typeFull":"∀ {α : Type u} {β : Type u_1} {b : β}, (Sum.inr b).IsRight","typeReadable":null,"typeReferences":[["Sum","IsRight"],["Sum","inr"]],"valueReferences":null},{"isProp":false,"kind":"definition","name":["FermatTriple","noConfusionType"],"typeFallback":"forall {k : Nat}, Sort.{u} -> (FermatTriple k) -> (FermatTriple k) -> Sort.{u}","typeFull":"{k : Nat} → Sort u → FermatTriple k → FermatTriple k → Sort u","typeReadable":null,"typeReferences":[["Nat"],["FermatTriple"]],"valueReferences":[["FermatTriple","casesOn"],["Nat"],["Eq"]]},{"isProp":false,"kind":"definition","name":["Demo","MyType","_sizeOf_1"],"typeFallback":"Demo.MyType -> Nat","typeFull":"Demo.MyType → Nat","typeReadable":null,"typeReferences":[["Demo","MyType"],["Nat"]],"valueReferences":[["Nat"],["instOfNatNat"],["OfNat","ofNat"],["Demo","MyType","rec"]]},{"isProp":false,"kind":"definition","name":["FermatTriple","_sizeOf_1"],"typeFallback":"forall {k : Nat}, (FermatTriple k) -> Nat","typeFull":"{k : Nat} → FermatTriple k → Nat","typeReadable":null,"typeReferences":[["Nat"],["FermatTriple"]],"valueReferences":[["instAddNat"],["instHPow"],["instHAdd"],["instPowNat"],["instNatPowNat"],["HPow","hPow"],["OfNat","ofNat"],["HAdd","hAdd"],["Nat"],["SizeOf","sizeOf"],["FermatTriple","rec"],["instOfNatNat"],["instSizeOfNat"],["instSizeOfDefault"],["Eq"]]},{"isProp":false,"kind":"definition","name":["pow'","match_1"],"typeFallback":"forall (motive : Nat -> Sort.{u_1}) (x._@.Example.1123838625._hygCtx.10.Example.1123838625._hygCtx._hyg.21 : Nat), (Unit -> (motive Nat.zero)) -> (forall (n : Nat), motive (Nat.succ n)) -> (motive x._@.Example.1123838625._hygCtx.10.Example.1123838625._hygCtx._hyg.21)","typeFull":"(motive : Nat → Sort u_1) → (x : Nat) → (Unit → motive Nat.zero) → ((n : Nat) → motive n.succ) → motive x","typeReadable":null,"typeReferences":[["Nat"],["Nat","succ"],["Nat","zero"],["Unit"]],"valueReferences":[["Nat","casesOn"],["Unit","unit"]]},{"isProp":false,"kind":"definition","name":["Demo","MyType","noConfusionType"],"typeFallback":"Sort.{v._@.Example.1702421504._hygCtx._hyg.5} -> Demo.MyType -> Demo.MyType -> Sort.{v._@.Example.1702421504._hygCtx._hyg.5}","typeFull":"Sort v✝ → Demo.MyType → Demo.MyType → Sort v✝","typeReadable":null,"typeReferences":[["Demo","MyType"]],"valueReferences":[]},{"isProp":false,"kind":"definition","name":["FermatTriple","noConfusion"],"typeFallback":"forall {k : Nat} {P : Sort.{u}} {x1 : FermatTriple k} {x2 : FermatTriple k}, (Eq.{1} (FermatTriple k) x1 x2) -> (FermatTriple.noConfusionType.{u} k P x1 x2)","typeFull":"{k : Nat} → {P : Sort u} → {x1 x2 : FermatTriple k} → Eq x1 x2 → FermatTriple.noConfusionType P x1 x2","typeReadable":null,"typeReferences":[["FermatTriple","noConfusionType"],["Nat"],["Eq"],["FermatTriple"]],"valueReferences":[["FermatTriple","casesOn"],["Nat"],["FermatTriple","noConfusionType"],["Eq","refl"],["Eq"],["Eq","ndrec"],["FermatTriple"]]},{"isProp":true,"kind":"theorem","name":["rw_test"],"typeFallback":"forall (x : Nat) (y : Nat) (z : Nat) (p : Nat -> Prop), (p (HMul.hMul.{0, 0, 0} Nat Nat Nat (instHMul.{0} Nat instMulNat) x y)) -> (p (HMul.hMul.{0, 0, 0} Nat Nat Nat (instHMul.{0} Nat instMulNat) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) x (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) (HMul.hMul.{0, 0, 0} Nat Nat Nat (instHMul.{0} Nat instMulNat) y (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (HMul.hMul.{0, 0, 0} Nat Nat Nat (instHMul.{0} Nat instMulNat) z (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))","typeFull":"∀ (x y z : Nat) (p : Nat → Prop),\n  p (instHMul.hMul x y) →\n    p (instHMul.hMul (instHAdd.hAdd x 0) (instHAdd.hAdd (instHAdd.hAdd 0 (instHMul.hMul y 1)) (instHMul.hMul z 0)))","typeReadable":null,"typeReferences":[["instAddNat"],["HAdd","hAdd"],["Nat"],["instOfNatNat"],["instHAdd"],["instMulNat"],["instHMul"],["HMul","hMul"],["OfNat","ofNat"]],"valueReferences":[["Nat","mul_one"],["instAddNat"],["Nat","add_zero"],["instHAdd"],["Nat","zero_add"],["HMul","hMul"],["OfNat","ofNat"],["congrArg"],["HAdd","hAdd"],["Nat"],["instOfNatNat"],["instMulNat"],["id"],["instHMul"],["Eq","mpr"],["Eq"],["Nat","mul_zero"]]},{"isProp":false,"kind":"inductive","name":["FermatTriple"],"typeFallback":"Nat -> Type","typeFull":"Nat → Type","typeReadable":null,"typeReferences":[["Nat"]],"valueReferences":null},{"isProp":true,"kind":"definition","name":["Option","IsSome","casesOn"],"typeFallback":"forall {α : Type.{u}} {motive : forall (a._@._internal._hyg.0 : Option.{u} α), (Option.IsSome.{u} α a._@._internal._hyg.0) -> Prop} {a._@._internal._hyg.0 : Option.{u} α} (t : Option.IsSome.{u} α a._@._internal._hyg.0), (forall {a : α}, motive (Option.some.{u} α a) (Option.IsSome.of_some.{u} α a)) -> (motive a._@._internal._hyg.0 t)","typeFull":"∀ {α : Type u} {motive : (a : Option α) → a.IsSome → Prop} {a : Option α} (t : a.IsSome),\n  (∀ {a : α}, motive (Option.some a) ⋯) → motive a t","typeReadable":null,"typeReferences":[["Option","IsSome","of_some"],["Option","IsSome"],["Option"],["Option","some"]],"valueReferences":[["Option","IsSome","rec"]]},{"isProp":false,"kind":"definition","name":["Option","instDecidablePredIsSome"],"typeFallback":"forall {α : Type.{u}}, DecidablePred.{succ u} (Option.{u} α) (Option.IsSome.{u} α)","typeFull":"{α : Type u} → DecidablePred Option.IsSome","typeReadable":null,"typeReferences":[["Option","IsSome"],["Option"],["DecidablePred"]],"valueReferences":[["Option","IsSome","of_some"],["Option","IsSome"],["Option","none"],["Decidable","isFalse"],["Decidable"],["Option","instDecidablePredIsSome","match_1"],["Option","neg_is_some_none"],["Option","some"],["Decidable","isTrue"]]},{"isProp":true,"kind":"recursor","name":["Sum","IsRight","rec"],"typeFallback":"forall {α : Type.{u}} {β : Type.{u_1}} {motive : forall (a._@._internal._hyg.0 : Sum.{u, u_1} α β), (Sum.IsRight.{u, u_1} α β a._@._internal._hyg.0) -> Prop}, (forall {b : β}, motive (Sum.inr.{u, u_1} α β b) (Sum.IsRight.of_right.{u, u_1} α β b)) -> (forall {a._@._internal._hyg.0 : Sum.{u, u_1} α β} (t : Sum.IsRight.{u, u_1} α β a._@._internal._hyg.0), motive a._@._internal._hyg.0 t)","typeFull":"∀ {α : Type u} {β : Type u_1} {motive : (a : Sum α β) → a.IsRight → Prop},\n  (∀ {b : β}, motive (Sum.inr b) ⋯) → ∀ {a : Sum α β} (t : a.IsRight), motive a t","typeReadable":null,"typeReferences":[["Sum","IsRight"],["Sum","IsRight","of_right"],["Sum","inr"],["Sum"]],"valueReferences":null},{"isProp":true,"kind":"theorem","name":["rcases_test"],"typeFallback":"forall {x : Nat}, (Exists.{1} Nat (fun (k : Nat) => Eq.{1} Nat x (HMul.hMul.{0, 0, 0} Nat Nat Nat (instHMul.{0} Nat instMulNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) k))) -> (Exists.{1} Nat (fun (k : Nat) => Eq.{1} Nat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) x (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (HMul.hMul.{0, 0, 0} Nat Nat Nat (instHMul.{0} Nat instMulNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) k)))","typeFull":"∀ {x : Nat}, (Exists fun k => Eq x (instHMul.hMul 2 k)) → Exists fun k => Eq (instHAdd.hAdd x 2) (instHMul.hMul 2 k)","typeReadable":null,"typeReferences":[["instAddNat"],["HAdd","hAdd"],["Nat"],["Exists"],["instHAdd"],["instOfNatNat"],["instMulNat"],["instHMul"],["HMul","hMul"],["Eq"],["OfNat","ofNat"]],"valueReferences":[["rfl"],["instAddNat"],["Exists"],["instHAdd"],["Exists","intro"],["HMul","hMul"],["OfNat","ofNat"],["congrArg"],["Exists","casesOn"],["HAdd","hAdd"],["Nat"],["instOfNatNat"],["id"],["instMulNat"],["instHMul"],["Eq","mpr"],["Eq"]]},{"isProp":true,"kind":"theorem","name":["comp_test"],"typeFallback":"forall (x : Nat), (Exists.{1} Nat (fun (k : Nat) => Eq.{1} Nat x (HMul.hMul.{0, 0, 0} Nat Nat Nat (instHMul.{0} Nat instMulNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) k))) -> (Exists.{1} Nat (fun (k : Nat) => Eq.{1} Nat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) x (OfNat.ofNat.{0} Nat 4 (instOfNatNat 4))) (HMul.hMul.{0, 0, 0} Nat Nat Nat (instHMul.{0} Nat instMulNat) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) k)))","typeFull":"∀ (x : Nat), (Exists fun k => Eq x (instHMul.hMul 2 k)) → Exists fun k => Eq (instHAdd.hAdd x 4) (instHMul.hMul 2 k)","typeReadable":null,"typeReferences":[["instAddNat"],["HAdd","hAdd"],["Nat"],["Exists"],["instHAdd"],["instOfNatNat"],["instMulNat"],["instHMul"],["HMul","hMul"],["Eq"],["OfNat","ofNat"]],"valueReferences":[["instAddNat"],["HAdd","hAdd"],["Nat"],["instOfNatNat"],["instHAdd"],["rcases_test"],["OfNat","ofNat"]]},{"isProp":false,"kind":"definition","name":["pow'","_sunfold"],"typeFallback":"forall {α : Type.{u}} [inst._@.Example.1123838625._hygCtx._hyg.3 : Mul.{u} α], α -> Nat -> α","typeFull":"{α : Type u} → [Mul α] → α → Nat → α","typeReadable":null,"typeReferences":[["Nat"],["Mul"]],"valueReferences":[["pow'","match_1"],["pow'"],["instHMul"],["HMul","hMul"]]},{"isProp":false,"kind":"definition","name":["pow'"],"typeFallback":"forall {α : Type.{u}} [inst._@.Example.1123838625._hygCtx._hyg.3 : Mul.{u} α], α -> Nat -> α","typeFull":"{α : Type u} → [Mul α] → α → Nat → α","typeReadable":null,"typeReferences":[["Nat"],["Mul"]],"valueReferences":[["pow'","match_1"],["Nat","below"],["instHMul"],["HMul","hMul"],["Nat","brecOn"]]},{"isProp":false,"kind":"definition","name":["_private","Example",0,"List","getLast?","match_1","splitter"],"typeFallback":"forall {α : Type.{u_1}} (motive : (List.{u_1} α) -> Sort.{u_2}) (x._@.Init.Data.List.Basic.417363870._hygCtx.10.Init.Data.List.Basic.417363870._hygCtx._hyg.21 : List.{u_1} α), (motive (List.nil.{u_1} α)) -> (forall (a : α) (as : List.{u_1} α), motive (List.cons.{u_1} α a as)) -> (motive x._@.Init.Data.List.Basic.417363870._hygCtx.10.Init.Data.List.Basic.417363870._hygCtx._hyg.21)","typeFull":"{α : Type u_1} →\n  (motive : List α → Sort u_2) →\n    (x : List α) → motive List.nil → ((a : α) → (as : List α) → motive (List.cons a as)) → motive x","typeReadable":null,"typeReferences":[["List","nil"],["List"],["List","cons"]],"valueReferences":[["List","casesOn"]]},{"isProp":false,"kind":"definition","name":["Demo","_aux_Example___macroRules_Demo_term_≋__1"],"typeFallback":"Lean.Macro","typeFull":"Lean.Macro","typeReadable":null,"typeReferences":[["Lean","Macro"]],"valueReferences":[["Lean","Name"],["Lean","TSyntax","raw"],["Lean","Macro","State"],["Lean","MonadQuotation","getCurrMacroScope"],["Lean","MacroScope"],["Lean","SourceInfo"],["Lean","Syntax","ident"],["String"],["Lean","Macro","Context"],["Lean","Macro","Exception","unsupportedSyntax"],["Lean","MonadRef","mkInfoFromRefPos"],["ReaderT","instApplicativeOfMonad"],["Lean","Syntax","Preresolved"],["List","cons"],["Bool","true"],["Lean","Syntax","Preresolved","decl"],["MonadExcept","throw"],["Lean","Name","mkStr4"],["Lean","SyntaxNodeKind"],["Lean","TSyntax","mk"],["EStateM","instMonad"],["Lean","Macro","instMonadQuotationMacroM"],["instMonadExceptOfMonadExceptOf"],["Lean","Syntax"],["instDecidableEqBool"],["Nat"],["Monad","toBind"],["String","toSubstring'"],["Bool"],["Applicative","toPure"],["ReaderT","instMonadExceptOf"],["EStateM"],["Lean","Syntax","isOfKind"],["PUnit"],["instOfNatNat"],["Lean","MonadQuotation","getContext"],["Lean","addMacroScope"],["Lean","MacroM"],["Eq"],["Lean","Name","mkStr2"],["Lean","Syntax","node2"],["EStateM","instMonadExceptOfOfBacktrackable"],["Bind","bind"],["List","nil"],["Lean","Name","mkStr1"],["ite"],["Lean","Macro","instMonadRefMacroM"],["Lean","Macro","Exception"],["ReaderT","instMonad"],["OfNat","ofNat"],["EStateM","nonBacktrackable"],["Lean","Syntax","getArg"],["Pure","pure"]]},{"isProp":true,"kind":"theorem","name":["pow'_succ"],"typeFallback":"forall {α : Type.{u}} [inst._@.Example.293554528._hygCtx._hyg.3 : Mul.{u} α] (x : α) (n : Nat), Eq.{succ u} α (pow'.{u} α inst._@.Example.293554528._hygCtx._hyg.3 x (Nat.succ n)) (HMul.hMul.{u, u, u} α α α (instHMul.{u} α inst._@.Example.293554528._hygCtx._hyg.3) (pow'.{u} α inst._@.Example.293554528._hygCtx._hyg.3 x n) x)","typeFull":"∀ {α : Type u} [inst : Mul α] (x : α) (n : Nat), Eq (pow' x n.succ) (instHMul.hMul (pow' x n) x)","typeReadable":null,"typeReferences":[["Nat"],["Nat","succ"],["pow'"],["Mul"],["instHMul"],["HMul","hMul"],["Eq"]],"valueReferences":[["rfl"],["Nat","succ"],["pow'"]]},{"isProp":true,"kind":"theorem","name":["Option","neg_is_some_none"],"typeFallback":"forall {α : Type.{u}}, Not (Option.IsSome.{u} α (Option.none.{u} α))","typeFull":"∀ {α : Type u}, Not Option.none.IsSome","typeReadable":null,"typeReferences":[["Not"],["Option","IsSome"],["Option","none"]],"valueReferences":[["Not"],["Option","IsSome"],["Nat"],["Lean","Name","anonymous"],["Option","none"],["sorryAx"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Lean","Name","num"],["OfNat","ofNat"]]},{"isProp":true,"kind":"theorem","name":["List","length","eq_def"],"typeFallback":"forall {α : Type.{u_1}} (x._@.Init.Prelude.210037673._hygCtx._hyg.9 : List.{u_1} α), Eq.{1} Nat (List.length.{u_1} α x._@.Init.Prelude.210037673._hygCtx._hyg.9) (List.length.match_1.{u_1, 1} α (fun (x._@.Init.Prelude.210037673._hygCtx.9.Init.Prelude.210037673._hygCtx._hyg.20 : List.{u_1} α) => Nat) x._@.Init.Prelude.210037673._hygCtx._hyg.9 (fun (_ : Unit) => OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) (fun (head._@.Init.Prelude.210037673._hygCtx._hyg.34 : α) (as : List.{u_1} α) => HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (List.length.{u_1} α as) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))","typeFull":"∀ {α : Type u_1} (x : List α),\n  Eq x.length (List.length.match_1 (fun x => Nat) x (fun _ => 0) fun head as => instHAdd.hAdd as.length 1)","typeReadable":null,"typeReferences":[["instAddNat"],["HAdd","hAdd"],["Nat"],["instHAdd"],["instOfNatNat"],["List"],["List","length","match_1"],["Eq"],["OfNat","ofNat"],["List","length"]],"valueReferences":[["instAddNat"],["List","nil"],["_private","Example",0,"List","length","match_1","splitter"],["instHAdd"],["List"],["List","length","match_1"],["List","length","eq_1"],["OfNat","ofNat"],["HAdd","hAdd"],["Nat"],["instOfNatNat"],["Eq","refl"],["Eq","symm"],["id"],["List","length","eq_2"],["Eq"],["Eq","ndrec"],["List","cons"],["List","length"]]},{"isProp":true,"kind":"theorem","name":["FermatTriple","mk","sizeOf_spec"],"typeFallback":"forall {k : Nat} (x : Nat) (y : Nat) (z : Nat) (eqn : Eq.{1} Nat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) x k) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) y k)) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) z k)), Eq.{1} Nat (SizeOf.sizeOf.{1} (FermatTriple k) (FermatTriple._sizeOf_inst k) (FermatTriple.mk k x y z eqn)) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)) (SizeOf.sizeOf.{1} Nat instSizeOfNat x)) (SizeOf.sizeOf.{1} Nat instSizeOfNat y)) (SizeOf.sizeOf.{1} Nat instSizeOfNat z)) (SizeOf.sizeOf.{0} (Eq.{1} Nat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) x k) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) y k)) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) z k)) (instSizeOfDefault.{0} (Eq.{1} Nat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) x k) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) y k)) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) z k))) eqn))","typeFull":"∀ {k : Nat} (x y z : Nat) (eqn : Eq (instHAdd.hAdd (instHPow.hPow x k) (instHPow.hPow y k)) (instHPow.hPow z k)),\n  Eq ((FermatTriple._sizeOf_inst k).sizeOf { x := x, y := y, z := z, eqn := eqn })\n    (instHAdd.hAdd\n      (instHAdd.hAdd (instHAdd.hAdd (instHAdd.hAdd 1 (instSizeOfNat.sizeOf x)) (instSizeOfNat.sizeOf y))\n        (instSizeOfNat.sizeOf z))\n      ((instSizeOfDefault (Eq (instHAdd.hAdd (instHPow.hPow x k) (instHPow.hPow y k)) (instHPow.hPow z k))).sizeOf eqn))","typeReadable":null,"typeReferences":[["instAddNat"],["instHPow"],["FermatTriple","_sizeOf_inst"],["instHAdd"],["instPowNat"],["HPow","hPow"],["instNatPowNat"],["OfNat","ofNat"],["FermatTriple"],["HAdd","hAdd"],["FermatTriple","mk"],["Nat"],["SizeOf","sizeOf"],["instSizeOfNat"],["instOfNatNat"],["instSizeOfDefault"],["Eq"]],"valueReferences":[["instAddNat"],["instHPow"],["instHAdd"],["instPowNat"],["instNatPowNat"],["HPow","hPow"],["OfNat","ofNat"],["HAdd","hAdd"],["Nat"],["SizeOf","sizeOf"],["instOfNatNat"],["instSizeOfNat"],["Eq","refl"],["instSizeOfDefault"],["Eq"]]},{"isProp":false,"kind":"definition","name":["Demo","MyType","toCtorIdx"],"typeFallback":"Demo.MyType -> Nat","typeFull":"Demo.MyType → Nat","typeReadable":null,"typeReferences":[["Demo","MyType"],["Nat"]],"valueReferences":[["Demo","MyType","ctorIdx"]]},{"isProp":true,"kind":"definition","name":["Sum","IsRight","casesOn"],"typeFallback":"forall {α : Type.{u}} {β : Type.{u_1}} {motive : forall (a._@._internal._hyg.0 : Sum.{u, u_1} α β), (Sum.IsRight.{u, u_1} α β a._@._internal._hyg.0) -> Prop} {a._@._internal._hyg.0 : Sum.{u, u_1} α β} (t : Sum.IsRight.{u, u_1} α β a._@._internal._hyg.0), (forall {b : β}, motive (Sum.inr.{u, u_1} α β b) (Sum.IsRight.of_right.{u, u_1} α β b)) -> (motive a._@._internal._hyg.0 t)","typeFull":"∀ {α : Type u} {β : Type u_1} {motive : (a : Sum α β) → a.IsRight → Prop} {a : Sum α β} (t : a.IsRight),\n  (∀ {b : β}, motive (Sum.inr b) ⋯) → motive a t","typeReadable":null,"typeReferences":[["Sum","IsRight"],["Sum","IsRight","of_right"],["Sum","inr"],["Sum"]],"valueReferences":[["Sum","IsRight","rec"]]},{"isProp":true,"kind":"theorem","name":["FermatTriple","mk","injEq"],"typeFallback":"forall {k : Nat} (x : Nat) (y : Nat) (z : Nat) (eqn : Eq.{1} Nat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) x k) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) y k)) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) z k)) (x_1 : Nat) (y_1 : Nat) (z_1 : Nat) (eqn_1 : Eq.{1} Nat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) x_1 k) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) y_1 k)) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) z_1 k)), Eq.{1} Prop (Eq.{1} (FermatTriple k) (FermatTriple.mk k x y z eqn) (FermatTriple.mk k x_1 y_1 z_1 eqn_1)) (And (Eq.{1} Nat x x_1) (And (Eq.{1} Nat y y_1) (Eq.{1} Nat z z_1)))","typeFull":"∀ {k : Nat} (x y z : Nat) (eqn : Eq (instHAdd.hAdd (instHPow.hPow x k) (instHPow.hPow y k)) (instHPow.hPow z k))\n  (x_1 y_1 z_1 : Nat) (eqn_1 : Eq (instHAdd.hAdd (instHPow.hPow x_1 k) (instHPow.hPow y_1 k)) (instHPow.hPow z_1 k)),\n  Eq (Eq { x := x, y := y, z := z, eqn := eqn } { x := x_1, y := y_1, z := z_1, eqn := eqn_1 })\n    (And (Eq x x_1) (And (Eq y y_1) (Eq z z_1)))","typeReadable":null,"typeReferences":[["FermatTriple","mk"],["instHPow"],["instAddNat"],["HAdd","hAdd"],["Nat"],["instHAdd"],["And"],["instPowNat"],["instNatPowNat"],["HPow","hPow"],["Eq"],["FermatTriple"]],"valueReferences":[["instHPow"],["instAddNat"],["HEq","refl"],["instHAdd"],["instPowNat"],["And"],["instNatPowNat"],["HPow","hPow"],["Eq","casesOn"],["FermatTriple"],["FermatTriple","mk"],["HAdd","hAdd"],["Eq","propIntro"],["And","intro"],["Nat"],["Eq","refl"],["Eq","symm"],["HEq"],["Eq"],["Eq","ndrec"],["FermatTriple","mk","noConfusion"],["And","casesOn"]]},{"isProp":false,"kind":"definition","name":["Demo","term_≋_"],"typeFallback":"Lean.TrailingParserDescr","typeFull":"Lean.TrailingParserDescr","typeReadable":null,"typeReferences":[["Lean","TrailingParserDescr"]],"valueReferences":[["Nat"],["Lean","ParserDescr","cat"],["Lean","Name","mkStr1"],["instOfNatNat"],["Lean","ParserDescr","trailingNode"],["Lean","ParserDescr","symbol"],["Lean","Name","mkStr2"],["OfNat","ofNat"],["Lean","ParserDescr","binary"]]},{"isProp":true,"kind":"theorem","name":["_private","Example",0,"List","length","match_1","eq_2"],"typeFallback":"forall {α : Type.{u_1}} (motive : (List.{u_1} α) -> Sort.{u_2}) (head._@.Init.Prelude.210037673._hygCtx._hyg.34 : α) (as : List.{u_1} α) (h_1 : Unit -> (motive (List.nil.{u_1} α))) (h_2 : forall (head._@.Init.Prelude.210037673._hygCtx._hyg.34 : α) (as : List.{u_1} α), motive (List.cons.{u_1} α head._@.Init.Prelude.210037673._hygCtx._hyg.34 as)), Eq.{u_2} (motive (List.cons.{u_1} α head._@.Init.Prelude.210037673._hygCtx._hyg.34 as)) (List.length.match_1.{u_1, u_2} α motive (List.cons.{u_1} α head._@.Init.Prelude.210037673._hygCtx._hyg.34 as) h_1 h_2) (h_2 head._@.Init.Prelude.210037673._hygCtx._hyg.34 as)","typeFull":"∀ {α : Type u_1} (motive : List α → Sort u_2) (head : α) (as : List α) (h_1 : Unit → motive List.nil)\n  (h_2 : (head : α) → (as : List α) → motive (List.cons head as)),\n  Eq (List.length.match_1 motive (List.cons head as) h_1 h_2) (h_2 head as)","typeReadable":null,"typeReferences":[["List","nil"],["List"],["List","length","match_1"],["Eq"],["List","cons"],["Unit"]],"valueReferences":[["Eq","refl"],["List","length","match_1"],["List","cons"]]},{"isProp":false,"kind":"definition","name":["FermatTriple","mk","noConfusion"],"typeFallback":"forall {k : Nat} (P : Sort.{u}) (x : Nat) (y : Nat) (z : Nat) (eqn : Eq.{1} Nat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) x k) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) y k)) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) z k)) (x' : Nat) (y' : Nat) (z' : Nat) (eqn' : Eq.{1} Nat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) x' k) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) y' k)) (HPow.hPow.{0, 0, 0} Nat Nat Nat (instHPow.{0, 0} Nat Nat (instPowNat.{0} Nat instNatPowNat)) z' k)), (Eq.{1} (FermatTriple k) (FermatTriple.mk k x y z eqn) (FermatTriple.mk k x' y' z' eqn')) -> ((Eq.{1} Nat x x') -> (Eq.{1} Nat y y') -> (Eq.{1} Nat z z') -> P) -> P","typeFull":"{k : Nat} →\n  (P : Sort u) →\n    (x y z : Nat) →\n      (eqn : Eq (instHAdd.hAdd (instHPow.hPow x k) (instHPow.hPow y k)) (instHPow.hPow z k)) →\n        (x' y' z' : Nat) →\n          (eqn' : Eq (instHAdd.hAdd (instHPow.hPow x' k) (instHPow.hPow y' k)) (instHPow.hPow z' k)) →\n            Eq { x := x, y := y, z := z, eqn := eqn } { x := x', y := y', z := z', eqn := eqn' } →\n              (Eq x x' → Eq y y' → Eq z z' → P) → P","typeReadable":null,"typeReferences":[["FermatTriple","mk"],["instHPow"],["instAddNat"],["HAdd","hAdd"],["Nat"],["instHAdd"],["instPowNat"],["instNatPowNat"],["HPow","hPow"],["Eq"],["FermatTriple"]],"valueReferences":[["FermatTriple","mk"],["FermatTriple","noConfusion"]]},{"isProp":true,"kind":"theorem","name":["eq_trans_sym"],"typeFallback":"forall {α : Type.{u}} {a : α} {b : α} {c : α}, (Eq.{succ u} α a b) -> (Eq.{succ u} α b c) -> (Eq.{succ u} α c a)","typeFull":"∀ {α : Type u} {a b c : α}, Eq a b → Eq b c → Eq c a","typeReadable":null,"typeReferences":[["Eq"]],"valueReferences":[["Eq","refl"],["id"],["Eq","mpr"],["Eq"],["congrArg"]]},{"isProp":true,"kind":"theorem","name":["_private","Example",0,"List","getLast?","match_1","eq_1"],"typeFallback":"forall {α : Type.{u_1}} (motive : (List.{u_1} α) -> Sort.{u_2}) (h_1 : Unit -> (motive (List.nil.{u_1} α))) (h_2 : forall (a : α) (as : List.{u_1} α), motive (List.cons.{u_1} α a as)), Eq.{u_2} (motive (List.nil.{u_1} α)) (List.getLast?.match_1.{u_1, u_2} α motive (List.nil.{u_1} α) h_1 h_2) (h_1 Unit.unit)","typeFull":"∀ {α : Type u_1} (motive : List α → Sort u_2) (h_1 : Unit → motive List.nil)\n  (h_2 : (a : α) → (as : List α) → motive (List.cons a as)),\n  Eq (List.getLast?.match_1 motive List.nil h_1 h_2) (h_1 Unit.unit)","typeReadable":null,"typeReferences":[["List","nil"],["List"],["List","getLast?","match_1"],["Eq"],["List","cons"],["Unit","unit"],["Unit"]],"valueReferences":[["List","nil"],["Eq","refl"],["List","getLast?","match_1"]]},{"isProp":false,"kind":"definition","name":["FermatTriple","_sizeOf_inst"],"typeFallback":"forall (k : Nat), SizeOf.{1} (FermatTriple k)","typeFull":"(k : Nat) → SizeOf (FermatTriple k)","typeReadable":null,"typeReferences":[["Nat"],["SizeOf"],["FermatTriple"]],"valueReferences":[["FermatTriple","_sizeOf_1"],["FermatTriple"],["SizeOf","mk"]]},{"isProp":false,"kind":"definition","name":["FermatTriple","z"],"typeFallback":"forall {k : Nat}, (FermatTriple k) -> Nat","typeFull":"{k : Nat} → FermatTriple k → Nat","typeReadable":null,"typeReferences":[["Nat"],["FermatTriple"]],"valueReferences":[]},{"isProp":false,"kind":"definition","name":["Demo","MyType","_sizeOf_inst"],"typeFallback":"SizeOf.{1} Demo.MyType","typeFull":"SizeOf Demo.MyType","typeReadable":null,"typeReferences":[["Demo","MyType"],["SizeOf"]],"valueReferences":[["Demo","MyType"],["Demo","MyType","_sizeOf_1"],["SizeOf","mk"]]}]
